# MatterStack v0.2.6 Implementation Report – Operator System v2 (Config-Driven Operator Routing, Multi-Instance Registries)

**Date:** 2025-12-14  
**Status:** Implemented + validated via unit/integration/e2e + full suite (green with the test-only mitigation flag)  
**Primary spec:** [`docs/DevGuides/DevGuide_v0.2.6.md`](docs/DevGuides/DevGuide_v0.2.6.md:1)  
**Baseline:** v0.2.5 “Task Attempts” + provenance-safe reruns ([`docs/DevGuides/v0.2.5_Report.md`](docs/DevGuides/v0.2.5_Report.md:1))

---

## 1. Executive Summary

MatterStack v0.2.6 refactors the “operator system” into a **portable, config-driven routing and wiring model** that supports:

- **Canonical operator keys** (`kind.name`, e.g. `hpc.default`) for stable routing across sites.
- **Multi-instance operator registries** configured via `operators.yaml`, allowing multiple HPCs/partitions/profiles side-by-side (e.g. `hpc.default` and `hpc.dev`) without campaign code changes.
- **Backwards-compatible routing** from legacy `operator_type` (e.g. `"HPC"`) to canonical keys (`hpc.default`).
- **Schema v3** addition: attempt-scoped `operator_key` on `task_attempts` for explicit, queryable routing metadata.

This is built on top of v0.2.5’s “Task Attempts” model and is designed to eliminate the confusion of “setting operator=HPC” while also implicitly choosing a site-specific partition or backend configuration.

---

## 2. Problem / Motivation (Why v0.2.6)

Prior to v0.2.6, operator routing and backend wiring were tightly coupled:
- Orchestrator routed using a single token (often `operator_type="HPC"`).
- CLI built a **fixed** operator registry with “HPC/Local/Human/Experiment”.
- There was no clean multi-instance path (e.g. “dev cluster” vs “prod cluster” without new flags/hardcoding).

v0.2.6 separates:
- **Routing**: “which conceptual operator should run this attempt?” (compute/human/experiment)
- **Wiring**: “how is that operator configured on this site?” (Slurm, ssh, partition, account, etc.)

---

## 3. Implementation Overview (What changed)

### 3.1 Canonical operator keys (new shared utility)

**Files:**
- [`matterstack/core/operator_keys.py`](matterstack/core/operator_keys.py:1)
- Unit tests: [`tests/unit/core/test_operator_keys.py`](tests/unit/core/test_operator_keys.py:1)

**Key behaviors:**
- Canonical key format: `kind.name` (lowercase).
- Parsing splits on first dot (supports hierarchical names later).
- Resolution precedence (used by orchestrator):
  1. attempt `operator_key` (schema v3)
  2. `operator_data["operator_key"]`
  3. legacy `operator_type` mapping (`"HPC"→hpc.default`, `"Local"→local.default`, etc.)

---

### 3.2 Schema v3: `task_attempts.operator_key` (durable routing metadata)

**Files:**
- Model: [`matterstack/storage/schema.py`](matterstack/storage/schema.py:124)
- Migration: [`matterstack/storage/state_store.py`](matterstack/storage/state_store.py:37)
- Tests:
  - [`tests/unit/core/test_schema_version.py`](tests/unit/core/test_schema_version.py:1)
  - [`tests/integration/test_state_store_sqlite.py`](tests/integration/test_state_store_sqlite.py:1)

**Migration semantics (additive):**
- Supported upgrade chain: v1 → v2 → v3.
- v2 → v3 backfills `operator_key` using:
  - `operator_data["operator_key"]` if present
  - else legacy mapping from `operator_type`
  - else leaves null

---

### 3.3 `operators.yaml`: config-driven multi-instance operator registry

**Files:**
- Config parser/validation: [`matterstack/config/operators.py`](matterstack/config/operators.py:1)
- Registry + factory/caching: [`matterstack/runtime/operators/registry.py`](matterstack/runtime/operators/registry.py:1)
- Unit tests:
  - [`tests/unit/config/test_operators_config.py`](tests/unit/config/test_operators_config.py:1)
  - [`tests/unit/runtime/test_operator_registry_factory.py`](tests/unit/runtime/test_operator_registry_factory.py:1)

**Core capabilities:**
- Multiple operator instances per kind (e.g. `hpc.default`, `hpc.dev`).
- Strict validation to prevent silent typos:
  - canonical key format required
  - config `kind:` must match key kind
  - unknown kinds and backend types rejected
  - extra fields rejected

**Compute backends supported (v0.2.6):**
- `local`
- `slurm`
- `profile` (reusing [`matterstack/config/profiles.py`](matterstack/config/profiles.py:1))
- `hpc_yaml` adapter path (legacy YAML config compatibility)

---

### 3.4 CLI changes: `--operators-config` (plus backward compatibility)

**Files:**
- CLI operator registry wiring: [`matterstack/cli/operator_registry.py`](matterstack/cli/operator_registry.py:1)
- CLI entrypoints: [`matterstack/cli/main.py`](matterstack/cli/main.py:1)
- Unit tests: [`tests/unit/cli/test_cli_operator_registry.py`](tests/unit/cli/test_cli_operator_registry.py:1)

**Behavior:**
- Preferred path: `--operators-config path/to/operators.yaml`
- Backward compatibility:
  - if `--operators-config` is absent, legacy `--hpc-config/--profile` behavior remains available
- The CLI now behaves as an “orchestrator runner”:
  - loads operators
  - runs ticks/loops
  - surfaces diagnostics/evidence
  - does not embed site-specific semantics into campaign logic

---

### 3.5 Orchestrator routing: operator_key resolution + deterministic failure

**Files:**
- Routing location: [`step_run()`](matterstack/orchestration/run_lifecycle.py:181)

**Behavior:**
- Attempt routing now uses canonical operator key resolution via [`matterstack/core/operator_keys.py`](matterstack/core/operator_keys.py:1).
- If resolved operator key is missing from registry, the orchestrator **fails the attempt deterministically** (rather than silently looping forever).

---

### 3.6 Evidence + diagnostics surfaces updated to include `operator_key`

**Files:**
- Evidence export: [`matterstack/storage/export.py`](matterstack/storage/export.py:1)
- Diagnostics/explain/frontier: [`matterstack/orchestration/diagnostics.py`](matterstack/orchestration/diagnostics.py:1)
- CLI attempts output: [`matterstack/cli/main.py`](matterstack/cli/main.py:1)
- Tests:
  - [`tests/unit/core/test_evidence_export.py`](tests/unit/core/test_evidence_export.py:1)
  - [`tests/unit/core/test_run_explain.py`](tests/unit/core/test_run_explain.py:1)

Outcome: `operator_key` is visible in operational tooling (attempt listings and exported evidence) so provenance is queryable.

---

## 4. Validation & Test Results

### 4.1 Targeted fixes validated (Catalyst human-in-loop timeouts)

Two e2e tests were previously timing out after operator/evidence semantics shifted to attempt-scoped directories. They were updated so the auto-approver writes the human response into the **attempt evidence directory** rather than a legacy `operators/human` directory.

Validated passing:
- [`tests/e2e/test_science_validation.py`](tests/e2e/test_science_validation.py:1)
- [`tests/e2e/test_workflow_execution.py`](tests/e2e/test_workflow_execution.py:1)

---

### 4.2 Full test suite (green)

Command executed in this environment:

- `MATTERSTACK_PYTEST_STUB_READLINE=1 python -m pytest`

Result (green):
- `182 passed, 2 skipped` (skips due to missing `thin_film_lab` workspace in repo)
- runtime ~34s (environment dependent)

The mitigation flag is test-only and is implemented by a startup hook in [`sitecustomize.py`](sitecustomize.py:1) (it stubs `readline` only when explicitly enabled).

---

## 5. New Coverage Added (Unit/Integration/E2E)

### Integration tests (new for operator-key routing)
- Mixed compute + human + experiment routing via operator keys:  
  [`tests/integration/test_run_lifecycle_mixed_operator_keys.py`](tests/integration/test_run_lifecycle_mixed_operator_keys.py:1)

- Multi-instance compute routing (proves `hpc.default` and `hpc.dev` can select distinct operator instances/backends):  
  [`tests/integration/test_run_lifecycle_multi_instance_compute_routing.py`](tests/integration/test_run_lifecycle_multi_instance_compute_routing.py:1)

### E2E test (new CLI + operators.yaml path)
- CLI `step/loop` with `--operators-config`, asserting `operator_key` persistence and evidence export coverage:  
  [`tests/e2e/test_cli_operators_config_routing_persistence_export.py`](tests/e2e/test_cli_operators_config_routing_persistence_export.py:1)

---

## 6. Backward Compatibility Guarantees

v0.2.6 preserves older behavior for existing runs/workspaces:

- Runs that only have legacy `operator_type` (e.g. `"HPC"`) still route successfully via legacy mapping.
- Registries can be built either via `--operators-config` (new) or legacy HPC config flags (compat).
- Schema migration is additive and does not destroy older v1/v2 runs.

---

## 7. Known Issues / Warnings Observed

1. Python deprecations:
   - Pydantic “class-based config” deprecation warnings (upstream).
   - `datetime.utcnow()` deprecations in [`matterstack/storage/state_store.py`](matterstack/storage/state_store.py:1). These are warnings only; no functional failures.

2. Two skipped tests:
   - The `thin_film_lab` workspace is missing from the repo, so those tests are skipped (expected).

3. Optional real-site validation:
   - v0.2.6 did not add a dedicated “live HPC operators.yaml validation workspace” beyond automated tests. This remains an optional recommended validation step.

---

## 8. How to Use (Operational Quickstart)

1. Create an `operators.yaml` defining at least:
   - `local.default`
   - `hpc.default` (if using HPC)
   - `human.default`
   - `experiment.default`

2. Run MatterStack using the CLI with config:
   - `matterstack step ... --operators-config path/to/operators.yaml`
   - or `matterstack loop ... --operators-config path/to/operators.yaml`

3. Expect attempts to persist `operator_key` and show it in attempt listings and evidence export.

(Exact CLI subcommands and flags are implemented in [`matterstack/cli/main.py`](matterstack/cli/main.py:1).)

---

## 9. Conclusion

v0.2.6 completes the planned operator-system refactor from [`docs/DevGuides/DevGuide_v0.2.6.md`](docs/DevGuides/DevGuide_v0.2.6.md:1):

- canonical operator keys
- schema v3 attempt operator_key
- config-driven multi-instance registries (`operators.yaml`)
- updated CLI plumbing and orchestrator routing
- expanded tests including new integration/e2e coverage
- full suite passing (with test-only mitigation flag in this environment)

This sets the foundation for adding new operator kinds (lab instruments, remote services) without embedding site-specific assumptions into campaign logic, while preserving compatibility with v0.2.5 and earlier workspaces.