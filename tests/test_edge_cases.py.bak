import pytest
from matterstack.core.domain import Material, StackTemplate
from matterstack.core.design_space import DesignSpace
from matterstack.core.environment import Environment
from matterstack.core.objective import Objective, Constraints
from matterstack.core.campaign_spec import CampaignConfig, Tier
from matterstack.runtime.context import RuntimeContext, HPCClient, LabClient
from matterstack.campaign.engine import CampaignState
from matterstack.core.operators import register_simulator

@register_simulator(name="sim_edge", tier="cheap")
def sim_edge(candidate, env, ctx):
    return {}

def get_base_config(ds):
    return CampaignConfig(
        name="test_edge",
        design_space=ds,
        environment=Environment("test", {}, "25C"),
        objective=Objective("score"),
        tiers=[Tier("t1", "sim_edge", 10)],
        strategy="grid",
    )

def test_empty_design_space():
    tmpl = StackTemplate("t", Material("m", "k"), [])
    ds = DesignSpace(tmpl)
    # ds has no dimensions
    
    config = get_base_config(ds)
    ctx = RuntimeContext(HPCClient(), LabClient())
    cs = CampaignState(config, ctx)
    
    # Depending on itertools.product behavior with empty list, this might produce one empty candidate or zero.
    # product() -> yields () -> 1 candidate with empty params.
    # But if we pass empty list to product? product(*[]) -> yields ()
    # If we pass product(*value_lists) where value_lists is [], it yields ()
    
    cs.run_grid_single_tier()
    assert len(cs.candidates) == 1
    assert cs.candidates[list(cs.candidates.keys())[0]].params == {}

def test_missing_lib_registry():
    tmpl = StackTemplate("t", Material("m", "k"), [])
    ds = DesignSpace(tmpl)
    ds.vary_discrete("p", "missing_lib")
    
    config = get_base_config(ds)
    ctx = RuntimeContext(HPCClient(), LabClient(), models={"lib_registry": {}})
    cs = CampaignState(config, ctx)
    
    with pytest.raises(KeyError):
        cs.run_grid_single_tier()